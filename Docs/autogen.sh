# A bash script to autogenerate a crude document listing all the following:
# keywords.
# built-in itentifiers.
# suffix strings.
# built-in function names.

# Although bash is traditionally a UNIX shell, a Windows user can run
# this script via the GitBash program, the bash shell that comes with
# git.  

# To Run this, open a bash (or GitBash) shell window and type the
# following:
#   cd $KOS_HOME  # Where $KOS_HOME is the directory where your kos project is.
#   cd Docs/
#   bash autogen.sh
#
# The output will be in the text file called "terms.txt"

# This script depends upon the code being formatted roughly uniformly,
# using rather consistent code everywhere, and is therefore a bit
# fragile.

OUT=`pwd`/terms.txt
TMP=`pwd`/autogen_tmp.txt
echo "Autogen making file 'terms.txt'"
echo "# terms.txt" > "$OUT"
echo "# This file is automatically generated by Autogen.sh - do not edit manually." >> "$OUT"
echo "# " >> "$OUT"

cd ..
KOS_HOME=`pwd`

#  ================== KEYWORDS ============================
echo "Keywords..."

echo "" >> "$OUT"
echo "[SYNTAX_TERMINALS]" >> "$OUT"
echo "" >> "$OUT"

(
  cat "$KOS_HOME/Compilation/KS/kRISC.tpg" | \
  grep -v -e '(EOF|WHITESPACE)' | \
  grep ' **-> *@' | \
  sed 's/^[A-Za-z_][A-Za-z_0-9]* *-> *@"\(.*\)" *;/\1/g' | \
  sed 's/|/\n/g' | \
  sed 's/\\\(.\)/\1/g' | \
  sed 's/(\(.\)/\1/g' | \
  sed 's/\(.\))/\1/g' | \
  tr 'a-z' 'A-Z' | \
  sed 's/^/  /g'
) >> "$OUT"
echo "" >> "$OUT"

#  ================== BOUND VARIABLES =====================
echo "Bound identifiers..."

echo "[BOUND IDENTIFIERS]" >> "$OUT"
echo "" >> "$OUT"
cd "$KOS_HOME/Binding"

CS_NAMES=`find . -name '*.cs' -print`
(
  for F_NAME in $CS_NAMES
  do 
    grep 'Add[GS]etter *([ \t]*"' "$F_NAME" | \
        sed 's/^.*Add[GS]etter *([ \t]*"\([^"]*\).*$/  \1/g' | \
        sort -k 2 | \
        tr 'a-z' 'A-Z' | \
        uniq
  done
) >> "$OUT"

cd "$KOS_HOME"

# ======================== SUFFIXES ==========================
echo "Suffixes..."

echo "" >> "$OUT"
echo "[SUFFIXES]" >> "$OUT"

cd "$KOS_HOME/Suffixed"
CS_FILES=`find . -name '*.cs' -print`
for FILE_NAME in $CS_FILES
do
  echo "" > "$TMP"
  STRIPPED_NAME="${FILE_NAME##*/}"
  STRIPPED_NAME="${STRIPPED_NAME%.cs}"
  echo "  [Suffixes of $STRIPPED_NAME]" >> "$TMP"
  echo "... of $STRIPPED_NAME"
  
  # Find the section file where a GetSuffix function might be defined:
  SUF_HEADER=`cat "$FILE_NAME" | grep -n 'public.*[GS]etSuffix'`   # contents of the declaration header line
  if [ "$SUF_HEADER" != "" ]
  then
    SUF_INDENT=${SUF_HEADER#[0-9]*:}                           #
    SUF_INDENT=${SUF_INDENT%%[^ \t]*}                          # string of spaces holding indentation level
    SUF_STARTLINE=`echo "$SUF_HEADER" | cut -d: -f1 | head -1` # Line number of the header line
    SUF_NUMLINES=`tail +$SUF_STARTLINE "$FILE_NAME" | \
                     grep -n "${SUF_INDENT}\}" | \
                     cut -d: -f1 | head -1`                          # how many lines is the function call?
                                                                     # calculated by looking for an ending
                                                                     # brace at the expected indent level
    let SUF_NUMLINES=$SUF_NUMLINES+2
    # Look just in that section for case statements with strings:
    ( tail +"$SUF_STARTLINE" "$FILE_NAME" | head -"$SUF_NUMLINES" | \
      grep 'case *"\([^"]*\)" *: *$' | sed 's/^\s*case\s*"\([^"]*\)"\s*:\s*$/    :\1/g' | \
      tr 'a-z' 'A-Z' 
    ) >> "$TMP"
    cat "$TMP" >> "$OUT"
  fi

  rm "$TMP"

done
cd "$KOS_HOME"

# ================ Functions ===================
echo "Functions..."
echo "" >> "$OUT"
echo "[FUNCTIONS]" >> "$OUT"
echo "" >> "$OUT"
cd "$KOS_HOME/Function"
CS_NAMES=`find . -name '*.cs' -print`
(
  for F_NAME in $CS_NAMES
  do 
    grep '\[FunctionAttribute *(' "$F_NAME" | \
        sed 's/^\s*\[FunctionAttribute\s*(\([^)]*\).*]/  \1/g' | \
        sed 's/"//g' | \
        tr 'a-z' 'A-Z' | \
        sort | \
        uniq
  done
) >> "$OUT"

cd "$KOS_HOME"
